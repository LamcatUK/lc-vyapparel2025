<?php
/**
 * Template Name: Theme Reference
 *
 * A visual reference page for theme colours, typography, buttons,
 * grid layout, blocks, and utility classes.
 *
 * @package lc-vyapparel2025
 */

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

get_header( 'nonav' );
?>
<div class="container-xl py-5">
	<h1>Theme Reference: <?= esc_html( basename( get_stylesheet_directory() ) ); ?></h1>

	<hr>
	<div class="button-group">
		<a href="#colours" class="button">Colours</a>
		<a href="#typography" class="button">Typography</a>
		<a href="#buttons" class="button">Buttons</a>
		<a href="#grid" class="button">Grid</a>
		<a href="#forms" class="button">Forms</a>
		<a href="#blocks" class="button">Blocks</a>
	</div>
	<hr>
	<a id="colours"></a>
	<?php require_once locate_template( 'reference-parts/colours.php' ); ?>
	<hr>
	<a id="typography"></a>
	<?php require_once locate_template( 'reference-parts/typography.php' ); ?>
	<hr>
	<a id="buttons"></a>
	<?php require_once locate_template( 'reference-parts/buttons.php' ); ?>
	<hr>
	<a id="grid"></a>
	<?php require_once locate_template( 'reference-parts/grid.php' ); ?>
	<hr>
	<a id="forms"></a>
	<?php require_once locate_template( 'reference-parts/forms.php' ); ?>
	<hr>
	<a id="blocks"></a>
	<?php require_once locate_template( 'reference-parts/blocks.php' ); ?>

	<hr>
	<p class="text--center small">Generated by <code>theme-reference.php</code> in theme root. Use for design QA and component audits.</p>
</div>
<?php

get_footer();

/**
 * Parses a CSS file and returns an associative array of class selectors and their rule blocks.
 *
 * @param string      $css_file_path Absolute path to the compiled CSS file.
 * @param string|null $prefix Optional: Only return classes starting with this prefix.
 *
 * @return array Associative array of class selectors and their CSS rules.
 */
function get_css_class_definitions( $css_file_path, $prefix = null ) {
	if ( ! file_exists( $css_file_path ) ) {
		return array();
	}

	$css = file_get_contents( $css_file_path );

	// Match class selectors with their rule blocks.
	preg_match_all( '/\.([a-z0-9\-_]+)\s*\{([^}]+)\}/i', $css, $matches, PREG_SET_ORDER );

	$classes = array();

	foreach ( $matches as $match ) {
		$class = trim( $match[1] );
		$rules = trim( $match[2] );

		// Optionally restrict by prefix.
		if ( $prefix && ! str_starts_with( $class, $prefix ) ) {
			continue;
		}

		// Clean up whitespace inside rules.
		$rules = preg_replace( '/\s*;\s*/', '; ', $rules );

		$classes[ $class ] = $rules;
	}

	ksort( $classes );
	return $classes;
}

/**
 * Converts an HSL color value to its RGB hexadecimal and RGB string representations.
 *
 * @param string $hsl The HSL color value in the format "H S% L%".
 *
 * @return array An array containing the RGB hexadecimal string and the RGB string.
 */
function hsl_to_rgb_hex( $hsl ) {
	preg_match( '/(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)%\s+(\d+(?:\.\d+)?)%/', $hsl, $parts );
	if ( count( $parts ) !== 4 ) {
		return array( '', '' );
	}
	$h = $parts[1];
	$s = $parts[2] / 100;
	$l = $parts[3] / 100;

	$c = ( 1 - abs( 2 * $l - 1 ) ) * $s;
	$x = $c * ( 1 - abs( fmod( $h / 60, 2 ) - 1 ) );
	$m = $l - $c / 2;

	if ( $h < 60 ) {
		$r = $c;
		$g = $x;
		$b = 0;
	} elseif ( $h < 120 ) {
		$r = $x;
		$g = $c;
		$b = 0;
	} elseif ( $h < 180 ) {
		$r = 0;
		$g = $c;
		$b = $x;
	} elseif ( $h < 240 ) {
		$r = 0;
		$g = $x;
		$b = $c;
	} elseif ( $h < 300 ) {
		$r = $x;
		$g = 0;
		$b = $c;
	} else {
		$r = $c;
		$g = 0;
		$b = $x;
	}

	$r = round( ( $r + $m ) * 255 );
	$g = round( ( $g + $m ) * 255 );
	$b = round( ( $b + $m ) * 255 );

	return array( sprintf( '#%02x%02x%02x', $r, $g, $b ), "rgb($r, $g, $b)" );
}

/**
 * Retrieves a cleaned-up description from a file's doc block if available.
 *
 * Looks for the first /** ... *\/ block in the file and returns the text before any @ tags.
 *
 * @param string $template_path Full path to the block template file.
 * @return string The cleaned-up description, or an empty string if not found.
 */
function get_template_description( $template_path ) {
	if ( ! file_exists( $template_path ) ) {
		return '';
	}
	$contents = file_get_contents( $template_path );
	if ( ! preg_match( '/\/\*\*(.*?)\*\//s', $contents, $docblock ) ) {
		return '';
	}
	$doc_content = trim( $docblock[1] );
	$lines       = preg_split( '/\R/', $doc_content );
	$description = array();
	foreach ( $lines as $line ) {
		// Remove leading asterisks and whitespace.
		$line = preg_replace( '/^\s*\*\s?/', '', $line );
		// Stop if a tag is reached.
		if ( strpos( $line, '@' ) === 0 ) {
			break;
		}
		if ( ! empty( $line ) ) {
			$description[] = $line;
		}
	}
	return implode( ' ', $description );
}